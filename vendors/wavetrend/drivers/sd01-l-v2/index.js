(()=>{var e={44(e,t,r){e.exports={...r(987),...r(110),...r(415)}},110(e){function t(e,r){if(Array.isArray(e)&&Array.isArray(r)||"object"==typeof e&&"object"==typeof r){for(let s in r)e[s]=t(e[s],r[s]);return e}return r}function r(e){let r=[],s=1;if(2!==e.type)throw"Unrecognised type for downlink decoding";s=2,e=t({downlink_hours:24,reporting_period:60,message_flags:{scald:!1,freeze:!1,debug:!1,history_count:0,simple:!1,act_poll:!0,stat_poll:!0},scald_threshold:60,freeze_threshold:4,config_type:[{flow_settling_count:0,config:0},{flow_settling_count:0,config:0},{flow_settling_count:0,config:0}],flow_delta:{cold:4,hot:10}},e),r.push(255&e.downlink_hours),r.push((65280&e.reporting_period)>>>8),r.push(255&e.reporting_period),r.push((0|e.message_flags.scald)>>>0|e.message_flags.freeze<<1>>>0|e.message_flags.debug<<2>>>0|(3&e.message_flags.history_count)<<3>>>0|e.message_flags.simple<<5>>>0|e.message_flags.act_poll<<6>>>0|e.message_flags.stat_poll<<7>>>0),r.push((255&e.scald_threshold)>>>0),r.push((255&e.freeze_threshold)>>>0);for(let t=0;t<3;t++)r.push((15&e.config_type[t].flow_settling_count)<<4>>>0|15&e.config_type[t].config);return r.push((15&e.flow_delta.cold)<<4>>>0|(15&e.flow_delta.hot)>>>0),{bytes:r,fPort:2}}e.exports={Encoder:function(e){try{return r(e).bytes}catch(e){return[]}},encodeDownlink:function(e){let t={warnings:[],errors:[]};try{let s=r(e.data);t.bytes=s.bytes,t.fPort=s.fPort}catch(e){t.errors.push(e)}return t},decodeDownlink:function(e){let t={warnings:[],errors:[]};try{t.data=function(e,t){let r=0,s={type:t};switch(s.type){case 2:s.downlink_hours=(255&e[r++])>>>0,s.reporting_period=((255&e[r++])<<8>>>0)+((255&e[r++])>>>0);let t=(255&e[r++])>>>0;s.message_flags={scald:!!(1&t),freeze:!!(2&t),debug:!!(4&t),history_count:t>>>3&3,simple:!!(32&t),act_poll:!!(64&t),stat_poll:!!(128&t)},s.scald_threshold=(255&e[r++])<<24>>24,s.freeze_threshold=(255&e[r++])<<24>>24,s.config_type=[];for(let t=0;t<3;t++){let o=(255&e[r++])>>>0;s.config_type[t]={flow_settling_count:o>>>4&15,config:(15&o)>>>0}}const o=(255&e[r++])>>>0;s.flow_delta={cold:(240&o)>>>4,hot:(15&o)>>>0};break;case 0:throw"LoRaWAN reserved payload type";case 1:throw"V1 Deprecated Payload, unsupported";default:throw"Unrecognised type for downlink decoding"}return s}(e.bytes,e.fPort)}catch(e){delete t.data,t.errors.push(e)}return t}}},415(e,t){t.extractPoints=function(e){const t={},r=e.message||{};function s(e,r,s){null==r||Number.isNaN(r)||(t[e]={unitId:"Cel",record:r},s&&(t[e].nature=s))}return void 0===r.minC&&void 0===r.maxC||(s("temperature:1",r.minC,"minC"),s("temperature:2",r.maxC,"maxC")),void 0===r.s1MinC&&void 0===r.s1MaxC||(s("temperature:3",r.s1MinC,"s1MinC"),s("temperature:4",r.s1MaxC,"s1MaxC"),s("temperature:5",r.s2MinC,"s2MinC"),s("temperature:6",r.s2MaxC,"s2MaxC"),s("temperature:7",r.s3MinC,"s3MinC"),s("temperature:8",r.s3MaxC,"s3MaxC")),void 0!==r.temperature&&s("temperature",r.temperature,"temperature"),Array.isArray(r.readings)&&r.readings.forEach(e=>{Array.isArray(e.sensors)&&e.sensors.forEach((r,s)=>{if(null==r||null==r.tempC||Number.isNaN(r.tempC))return;const o=`temperature:${10+s}`;t[o]||(t[o]={unitId:"Cel",records:[]}),t[o].records.push({value:r.tempC,eventTime:e.timestamp??null}),t[o].nature="tempC"})}),t}},987(e){function t(e){return(255&e)<<24>>24}function r(e){return(255&e)>>>0}function s(e,s){let o={},n=0;switch(s){case 2:const s=r(e[n++]);o.pvd_level=s>>>3&7,o.sensor=[!!(1&s),!!(2&s),!!(4&s)],o.firmware_version={major:r(e[n++]),minor:r(e[n++])},o.reset_reason=(e[n++]<<8>>>0)+r(e[n++]);break;case 3:o.timestamp=(r(e[n++])<<24>>>0)+(r(e[n++])<<16>>>0)+(r(e[n++])<<8>>>0)+r(e[n++]),o.sensor_id=3&e[n++],o.minC=t(e[n++]),o.maxC=t(e[n++]),o.events=e[n++],o.reports=e[n++];break;case 4:{o.error_code=e[n++],o.downlink_hours=e[n++],o.reporting_period=((255&e[n++])<<8>>>0)+((255&e[n++])>>>0);let t=(255&e[n++])>>>0;o.message_flags={scald:!!(1&t),freeze:!!(2&t),debug:!!(4&t),history_count:t>>>3&3,simple:!!(32&t),act_poll:!!(64&t),stat_poll:!!(128&t)},o.scald_threshold=(255&e[n++])<<24>>24,o.freeze_threshold=(255&e[n++])<<24>>24,o.config_type=[];for(let t=0;t<3;t++){let r=(255&e[n++])>>>0;o.config_type[t]={flow_settling_count:r>>>4&15,config:(15&r)>>>0}}const r=(255&e[n++])>>>0;o.flow_delta={cold:(240&r)>>>4,hot:15&r};break}case 5:o.sensor_id=3&e[n++];break;case 6:o.error_code=(r(e[n++])<<8>>>0)+r(e[n++]),o.file_hash=(r(e[n++])<<8>>>0)+r(e[n++]),o.line=(r(e[n++])<<8>>>0)+r(e[n++]);break;case 7:case 8:o.sensor_id=3&e[n++],o.temperature=t(e[n++]);break;case 9:{let t=[];const s=(r(e[n++])<<24>>>0)+(r(e[n++])<<16>>>0)+(r(e[n++])<<8>>>0)+r(e[n++]),a=r(e[n++]);let i=(30&a)>>1;i=1&a?i/10:10*i;const l=(224&a)>>5;for(;n<e.length;){const o={timestamp:s,sensors:[{direction:0,state:0,report:!1,tempC:NaN},{direction:0,state:0,report:!1,tempC:NaN},{direction:0,state:0,report:!1,tempC:NaN}]};for(let t=0;t<3;t++){const s=(r(e[n++])<<8>>>0)+r(e[n++]);o.sensors[t].direction=(49152&s)>>14,o.sensors[t].state=(12288&s)>>12,o.sensors[t].report=(2048&s)>>11==1;const a=2047&s;o.sensors[t].tempC=2047===a?null:(a-270)/10}t.push(o)}t.forEach((e,r)=>{e.timestamp-=(t.length-1-r)*i}),o.timestamp=s,o.pvd_level=l,o.readings=t;break}case 10:o.timestamp=(r(e[n++])<<24>>>0)+(r(e[n++])<<16>>>0)+(r(e[n++])<<8>>>0)+r(e[n++]),o.s1MinC=t(e[n++]),o.s1MaxC=t(e[n++]),o.s2MinC=t(e[n++]),o.s2MaxC=t(e[n++]),o.s3MinC=t(e[n++]),o.s3MaxC=t(e[n++]);break;default:throw"Unrecognised type for uplink decoding"}return o}e.exports={Decoder:function(e,t){try{return s(e,t)}catch(e){return null}},decodeUplink:function(e){let t={warnings:[],errors:[]};try{t.data=s(e.bytes,e.fPort)}catch(e){t.errors.push(e)}return t}}}},t={},r=function r(s){var o=t[s];if(void 0!==o)return o.exports;var n=t[s]={exports:{}};return e[s](n,n.exports,r),n.exports}(44),s=exports;for(var o in r)s[o]=r[o];r.__esModule&&Object.defineProperty(s,"__esModule",{value:!0})})();